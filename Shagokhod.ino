//                      Подключаем библиотеки:                                            //
#include <Servo.h>   
#include <SoftwareSerial.h>
#define REMOTEXY_MODE__HARDSERIAL

#include <RemoteXY.h>

#define REMOTEXY_SERIAL Serial
#define REMOTEXY_SERIAL_SPEED 9600// Создаем объект objSensor указывая номера выводов к которым подключён датчик расстояния HC-SR04+ (Trig к выводу 3, Echo к выводу 2)
Servo                   objServo[8];  /*  0    1    2    3    4    5    6    7   */       // Создаём массив, каждый элемент которого является объектом библиотеки Servo. Цифры в комментарии указывают на № сервопривода
//                      Определяем сервы: Г    В    Г    В    Г    В    Г    В            // Буквы в комментарии указывают на плоскость вращения сервопривода (Горизонтальная / Вертикальная)
const uint8_t           pinServo[8] = {   4,   5,   6,   7,   8,   9,  10,  11   };       // Определяем массив хранящий номера выводов к которым подключены сервоприводы (можно менять)
const int               cenAngle[8] = {  90,  90,  90,  90,  90,  90,  90,  90   };       // Определяем массив хранящий углы в градусах, при которых сервоприводы находятся в центральном положении (КОРРЕКТИРУЕТСЯ В КАЛИБРОВОЧНОМ СКЕТЧЕ)
const int               minAngle[8] = {  50,  30,  50,  30,  50,  30,  50,  30   };       // Определяем массив хранящий углы в градусах, на которые отклоняются сервоприводы от центрального положения назад  или вниз
const int               maxAngle[8] = {  50,  40,  50,  40,  50,  40,  50,  40   };       // Определяем массив хранящий углы в градусах, на которые отклоняются сервоприводы от центрального положения вперёд или вверх
//                      Определяем константы:                                             //
const uint8_t           pinK        = 12;                                                 // Определяем константу pinK указывая номер вывода Arduino к которой подключена кнопка сопряжения
const uint32_t          minDelay    = 1000;                                               // Задержка для максимальной скорости (чем ниже значение тем выше скорость)
const uint32_t          maxDelay    = 10000;                                              // Задержка для минимальной скорости  (чем ниже значение тем выше скорость)
//                      Объявляем функции:                                                //
void                    funLimbMove   ( uint8_t, bool, int8_t );                          // Объявляем Функцию установки  одного сустава     в значение от -100 до 100 (конечность 1-4, сустав 0/1, положение -100...+100)
void                    funLimbStep   ( uint8_t, uint8_t, int, int );                     // Объявляем Функцию установки  одной  конечности  в положение от 0 до 255   (конечность 1-4, положение 0...255, ограничение по горизонтали -100...+100, ограничение по вертикали 0...100%)
void                    funLimbGait   ( uint8_t, uint8_t, int, int );                     // Объявляем Функцию установки  всех   конечностей в положение от 0 до 255   (тип походки 0-4, положение 0...255, ограничение по горизонтали -100...+100, ограничение по вертикали 0...100%)
void                    funLimbFree   ( void );                                           // Объявляем Функцию ослабления всех   суставов                              (без параметров)
void                    funLimbCent   ( void );                                           // Объявляем Функцию установки  всех   суставов в центральное положение      (без параметров)
void                    funWaitMaster ( void );                                           // Объявляем Функцию удаления списка пар и ожидания мастера в роли ведомого  (без параметров)
//                      Объявляем массив для получения данных от мастера:                 // 
int8_t                  arrData[4];                                                       // Объявляем массив arrData значения которого будут обнавляться по bluetooth, можно создавать массивы или переменные любых типов в т.ч. и char
//                      Определяем дополнительные переменные:                             //
uint8_t                 varPosition = 0;                                                  // Текущая позиция походки от 0 до 255 (чем быстрее меняется значение тем выше скорость, если значение увеличивается - значит вперёд, если значение уменьшается - значит назад)
bool                    f           = false;                                              // Флаг запрещающий чтение данных более 1 раза за отведённое время
uint8_t                 sumPultErr  = 20;          
int button=1;// Количество ошибок чтения данных с пульта
// конфигурация интерфейса  
#pragma pack(push, 1)

uint8_t RemoteXY_CONF[] =   // 52 bytes
  { 255,5,0,0,0,45,0,16,31,0,5,32,16,28,30,30,2,26,31,3,
  5,85,8,6,29,2,26,4,0,65,22,12,35,2,26,10,48,11,6,13,
  13,4,26,31,79,78,0,31,79,70,70,0 };
  
// структура определяет все переменные и события вашего интерфейса управления 
struct {

    // input variables
  int8_t joystick_1_x; // oт -100 до 100  
  int8_t joystick_1_y; // oт -100 до 100  
  uint8_t select_1; // =0 если переключатель в положении A, =1 если в положении B, =2 если в положении C, ... 
  int8_t slider_1; // =0..100 положение слайдера 
  uint8_t pushSwitch_1; // =1 если включено, иначе =0 

    // other variable
  uint8_t connect_flag;  // =1 if wire connected, else =0 

} RemoteXY;
#pragma pack(pop)
                                                                                         
void setup(){                                                                             
     funLimbFree();                                                                       
     pinMode(pinK, INPUT); 
       RemoteXY_Init (); 
  Serial.begin(9600);
  pinMode(LED_BUILTIN, OUTPUT);
     // Переводим вывод pinK (кнопка сопряжения) в режим вхо\                                                                
}                                                                                         
                                                                                          
void loop(){    
  RemoteXY_Handler ();//
//   Получаем данные с пульта (один раз за каждые 50 мс):                                 
     if(millis()%50<5){
      arrData[0] = RemoteXY.joystick_1_x;
      arrData[1] = RemoteXY.joystick_1_y;
      arrData[2] = RemoteXY.slider_1;
      arrData[3] = 0;
      }
      if(RemoteXY.pushSwitch_1 == 0){funLimbFree();}// Каждые 50мс в течении первых 5мс ...
                                                                              // Если первые 5мс из очередных 50мс прошли, то устанавливаем флаг «f».
//   Проверяем наличие препятствий (один раз за полный шаг):                              //                                                                           //
//   Шагаем:                                                                              //
     if(1){                                                                   // Если данные с пульта приходят, то ...
//       Вперёд или назад:                                                                //
         if(arrData[1]!=0){                                                               // Если джойстик отклонён вперёд arrData[1]>0 или назад arrData[1]<0, то ...
             if(arrData[1]>0){varPosition++;}                                             // Если джойстик отклонён вперёд, то увеличиваем позицию походки varPosition.
             else            {varPosition--;}                                             // Если джойстик отклонён назад,  то уменьшаем   позицию походки varPosition.
             delayMicroseconds(map(abs(arrData[1]),1,100,maxDelay,minDelay));             // Скорость: устанавливаем задержку в зависимости от степени отклонения джойстика вперёд или назад: abs(arrData[1]) без знака. Чем дальше отклонён джойстик, тем меньше задержка, следовательно, выше скорость.
             funLimbGait(1, varPosition, arrData[0], arrData[2]);                         // Обращаемся к функции выполнения походки funLimbGait, аргументы: походка №1, позиция varPosition, поворот arrData[0], высота arrData[2].
//       Разворот:                                                                        //
         }else if(arrData[0]!=0){                                                         // Иначе (если джойстик не отклонён вперёд или назад), но отклонён влево arrData[0]<0 или вправо arrData[0]>0, то ...
             if(arrData[0]>0){varPosition++;}                                             // Если джойстик отклонён вправо, то увеличиваем позицию походки varPosition.
             else            {varPosition--;}                                             // Если джойстик отклонён влево,  то уменьшаем   позицию походки varPosition.
             delayMicroseconds(map(abs(arrData[0]),1,100,maxDelay,minDelay));             // Скорость: устанавливаем задержку в зависимости от степени отклонения джойстика влево или вправо: abs(arrData[0]) без знака. Чем дальше отклонён джойстик, тем меньше задержка, следовательно, выше скорость.
             funLimbGait(0, varPosition, 0, arrData[2]);                                  // Обращаемся к функции выполнения походки funLimbGait, аргументы: походка №0 (разворот), позиция varPosition, любое значение, высота arrData[2].
//       Стоим на месте:                                                                  //
         }else{                                                                           // Иначе (если джойстик не отклонён вперёд или назад, или влево, или вправо) ...
             funLimbMove(1, 1, map(arrData[2],0,100,+100,-100));                          // Обращаемся к функции установки одного сустава конечности funLimbMove, аргументы: 1-номер конечности, 1-вертикальный сустав, arrData[2]-высота сустава.
             funLimbMove(2, 1, map(arrData[2],0,100,+100,-100));                          // Обращаемся к функции установки одного сустава конечности funLimbMove, аргументы: 2-номер конечности, 1-вертикальный сустав, arrData[2]-высота сустава.
             funLimbMove(3, 1, map(arrData[2],0,100,+100,-100));                          // Обращаемся к функции установки одного сустава конечности funLimbMove, аргументы: 3-номер конечности, 1-вертикальный сустав, arrData[2]-высота сустава.
             funLimbMove(4, 1, map(arrData[2],0,100,+100,-100));                          // Обращаемся к функции установки одного сустава конечности funLimbMove, аргументы: 4-номер конечности, 1-вертикальный сустав, arrData[2]-высота сустава.
         }                                                                                //
//   Если нет данных от пульта:                                                           //
     }else{ funLimbFree(); }                                                              // Если пульт отключился то ослабляем все суставы
//   Устанавливаем все конечности в центральные положения при нажатии на джойстик:        //
     if(arrData[3]){ funLimbCent(); }                                                     // Если нажат джойстик пульта, устанавливаем все конечности в центральные положения                                                                    // Если нажата кнопка сопряжения, то устанавливаем bluetooth модулю роль ведомого с именем "QUADRUPED" и PIN-кодом 1212, ожидающего подключение мастера (список сопряжённых пар будет очищен).
}                                                                                         //
                                                                                          //
// ====================================================================================== //
                                                                                          //
//   Функция установки одного сустава конечности в значение от -100 до 100:               //
void funLimbMove(uint8_t num, bool joint, int8_t pos){                                    // Аргументы функции: «num» - номер конечности от 1 до 4 , «joint» - тип сустава 0 (горизонтальный) или 1 (вертикальный) , «pos» - положение сустава от -100 (внизу-сзади) до +100 (вверху-спереди)
     uint8_t   i = (num-1) * 2 + joint;                                                   // Определяем № сервопривода (i) по № конечности (num-1) и типу сустава (joint)
     int       k = 0, j = pos? cenAngle[i]:0;                                             // Определяем переменные (j) и (k) для хранения экстремумов
     if(pos>0){k = +100; if( num%2==0||i%2==1 ){j-=maxAngle[i];}else{j+=maxAngle[i];}}    // Находим (k) - максимально допустимое значение для аргумента (pos). Находим (j) - максимально допустимый угол в градусах.
     if(pos<0){k = -100; if( num%2==1&&i%2==0 ){j-=minAngle[i];}else{j+=minAngle[i];}}    // Находим (k) - минимально  допустимое значение для аргумента (pos). Находим (j) - минимально  допустимый угол в градусах.
     if(!objServo[i].attached()){objServo[i].attach(pinServo[i]);}                        // Подключаем объект (objServo) работающий с сервоприводом (i) к выводу (pinServo[i])
         objServo[i].write(map(pos, 0, k, cenAngle[i], j));                               // Устанавливаем сервопривод (i) в угол находящийся между центром (cenAngle[I]) и экстремумом (j)
}                                                                                         //
//   Функция установки одной конечности в положение от 0 до 255:                          //
void funLimbStep(uint8_t num, uint8_t pos, int hor, int ver){                             // Аргументы функции: «num» - номер конечности от 1 до 4 , «pos» - позиция от 0 до 255 , «hor» - ограничение поворота горизонтального сустава от -100 до +100 , «ver» - ограничение высоты вертикального сустава от 0 до 100%
     int i, j;                                                                            // Объявляем переменные (i) - для
     if(pos < 225){i = map(pos,   0, 212, +100, -100); }else                              // Сустав конечности поворачивается назад                            (+100 >>> -100)
                  {i = map(pos, 225, 255, -100, +100); }                                  // Сустав конечности поворачивается вперёд                           (-100 >>> +100)
     if(pos < 225){j =                    -100;        }else                              // Сустав конечности опущен                                          (-100)
     if(pos < 235){j = map(pos, 225, 235, -100, +100); }else                              // Сустав конечности поднимается вверх                               (-100 >>> +100)
     if(pos < 245){j =                    +100;        }else                              // Сустав конечности поднят                                          (+100)
                  {j = map(pos, 245, 255, +100, -100); }                                  // Сустав конечности опускается вниз                                 (+100 >>> -100)
     if(hor<0 && num%2==1){ i = map(i, -100, +100, -(100+hor)  , 100+hor);}               // Ограничиваем  угол (i) горизонтального сустава левых  конечностей (поворот влево)
     if(hor>0 && num%2==0){ i = map(i, -100, +100, -(100-hor)  , 100-hor);}               // Ограничиваем  угол (i) горизонтального сустава правых конечностей (поворот вправо)
                            j = map(j, -100, +100, ver*(-2)+100, 100    );                // Ограничиваем  угол (j) вертикального   сустава любых  конечностей (высота хексапода)
     funLimbMove(num, 0, i);                                                              // Устанавливаем угол (i) для горизонтального (0) сустава конечности (num)
     funLimbMove(num, 1, j);                                                              // Устанавливаем угол (j) для вертикального   (1) сустава конечности (num)
}                                                                                         //
//   Функция выполнения походки по одному из возможных вариантов i                        //
void funLimbGait(uint8_t num, uint8_t pos, int hor, int ver){                             // Аргументы функции: (num) - номер походки от 0 до 2 , (pos) - позиция от 0 до 255 , «hor» - ограничение поворота горизонтальных суставов от -100 до +100 , «ver» - ограничение высоты вертикального сустава от 0 до 100%
     switch(num){                                                                         //
//       Походка номер 0: разворот на месте:                                              // pos = 0         63       127       191       255
         case 0:                                                                          //       |         |         |         |         |
             funLimbStep(1,  31+pos, hor, ver);                                           //  L    | > > > > | > > > > | > > > > | <<< > > | конечность №1 выполняет полный цикл движений (от 255 до 0) быстро возвращаясь в последней тетраде
             funLimbStep(2,   0-pos, hor, ver);                                           //  R    | >>> < < | < < < < | < < < < | < < < < | конечность №2 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в первой тетраде
             funLimbStep(3,  95+pos, hor, ver);                                           //  L    | > > > > | > > > > | <<< > > | > > > > | конечность №3 выполняет полный цикл движений (от 255 до 0) быстро возвращаясь в предпоследней тетраде
             funLimbStep(4,  63-pos, hor, ver);                                           //  R    | < < < < | >>> < < | < < < < | < < < < | конечность №4 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь во второй тетраде
         break;                                                                           //       |         |         |         |         |
//       Походка номер 1: движение вперёд или назад:                                      // pos = 0         63       127       191       255
         case 1:                                                                          //       |         |         |         |         |
             funLimbStep(1,   0+pos, hor, ver);                                           //  L    | > > > > | > > > > | > > > > | > > <<< | конечность №1 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
             funLimbStep(2, 127+pos, hor, ver);                                           //  R    | > > > > | > > <<< | > > > > | > > > > | конечность №2 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь во второй тетраде
             funLimbStep(3,  63+pos, hor, ver);                                           //  L    | > > > > | > > > > | > > <<< | > > > > | конечность №3 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в предпоследней тетраде
             funLimbStep(4, 191+pos, hor, ver);                                           //  R    | > > <<< | > > > > | > > > > | > > > > | конечность №4 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в первой тетраде
         break;                                                                           //       |         |         |         |         |
//       Походка номер 2: плывёт вперёд или назад:                                        // pos = 0         63       127       191       255
         case 2:                                                                          //       |         |         |         |         |
             funLimbStep(1,   0+pos, hor, ver);                                           //  L    | > > > > | > > > > | > > > > | > > <<< | конечность №1 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
             funLimbStep(2,   0+pos, hor, ver);                                           //  R    | > > > > | > > > > | > > > > | > > <<< | конечность №2 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
             funLimbStep(3,   0+pos, hor, ver);                                           //  L    | > > > > | > > > > | > > > > | > > <<< | конечность №3 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
             funLimbStep(4,   0+pos, hor, ver);                                           //  R    | > > > > | > > > > | > > > > | > > <<< | конечность №4 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
         break;                                                                           //       |         |         |         |         |
}    }                                                                                    //
//   Функция освобождения конечностей:                                                    // Аргументы функции: отсутствуют
void funLimbFree(void){for(uint8_t i=0;i<8;i++){objServo[i].detach();digitalWrite(pinServo[i],LOW);}}
//   Функция установки всех суставов конечностей в центральное положение:                 // Аргументы функции: отсутствуют
void funLimbCent(void){for(uint8_t i=1;i<=4;i++){funLimbMove(i,0,0);funLimbMove(i,1,0);}} //
//   Функция удаления списка пар и ожидания мастера в роли ведомого при нажатии кнопки    // Аргументы функции: отсутствуют
