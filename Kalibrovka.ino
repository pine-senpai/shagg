#include         <Servo.h>                                                                  // Подключаем библиотеку Servo, для работы с сервопривод
//               Объявляем объекты для работы с библиотеками:                               //                                      
Servo            objServo[8];         /*  0    1    2    3    4    5    6    7   */         // Создаём массив, каждый элемент которого является объектом библиотеки Servo. Цифры в комментарии указывают на № сервопривода
//               Определяем массивы:      Г    В    Г    В    Г    В    Г    В              // Буквы в комментарии указывают на плоскость вращения сервопривода (Горизонтальная / Вертикальная)
const uint8_t    pinServo[8]  =       {   4,   5,   6,   7,   8,   9,  10,  11   };         // Определяем массив хранящий номера выводов к которым подключены сервоприводы (можно менять)
const int        cenAngle[8]  =       {  90,  90,  90,  90,  90,  90,  90,  90   };         // Определяем массив хранящий углы в градусах, при которых сервоприводы находятся в центральном положении (КОРРЕКТИРУЕТСЯ В КАЛИБРОВОЧНОМ СКЕТЧЕ)
const int        minAngle[8]  =       {  50,  30,  50,  30,  50,  30,  50,  30   };         // Определяем массив хранящий углы в градусах, на которые отклоняются сервоприводы от центрального положения назад  или вниз
const int        maxAngle[8]  =       {  50,  40,  50,  40,  50,  40,  50,  40   };         // Определяем массив хранящий углы в градусах, на которые отклоняются сервоприводы от центрального положения вперёд или вверх
//               Объявляем функции устанавливающие сервоприводы в определённые позиции:     //
void             funLimbMove          ( uint8_t, bool, int8_t );                            // Объявляем Функцию установки  одного сустава     в значение от -100 до 100 (конечность 1-4, сустав 0/1, положение -100...+100)
void             funLimbStep          ( uint8_t, uint8_t );                                 // Объявляем Функцию установки  одной  конечности  в положение от 0 до 255   (конечность 1-4, положение 0...255)
void             funLimbGait          ( uint8_t, uint8_t );                                 // Объявляем Функцию установки  всех   конечностей в положение от 0 до 255   (тип походки 0-4, положение 0...255)
void             funLimbFree          ( void );                                             // Объявляем Функцию ослабления всех   суставов                              (без параметров)
void             funLimbCent          ( void );                                             // Объявляем Функцию установки  всех   суставов в центральное положение      (без параметров)
//               Определяем переменные отвечающие за направление и высоту:                  //
int              limWidth      =       0;                                                   // Определяем переменную для выбора направления движения                     (-100 влево, +100 вправо, 0 прямо)
uint8_t          limHeight     =       100;                                                 // Определяем переменную для ограничения высоты хексапода                    (0 ползком, 100 на высоте)
//               Определяем переменные участвующие только в коде функции loop:              //
uint8_t          a             =       1;                                                   // Текущая позиция походки от 0 до 255 (чем быстрее меняется значение тем выше скорость, если значение увеличивается - значит вперёд, если значение уменьшается - значит назад)
uint8_t          b             =       1;                                                   // Варианты движений (походок) от 1 до 9
uint8_t          c             =       0;                                                   // Счетчик остановки
bool             d             =       false;                                               // Флаг разрешающий сделать очередной шаг
bool             e             =       false;                                               // Флаг разрешающий перейти к очередной походке
                                                                                            //
void setup(){    funLimbCent();}                                                            // Устанавливаем все конечности в центральные положения
                                                                                            //
void loop(){                                                                                //
     if(1){                                                                                // Если счётчик установлен в 0, то ...
         if(millis() %    3 < 2){if(d){a++; d=false;}}else{d=true;}                         // Увеличиваем   значение переменной (a) на 1 за каждые 3 мс  (т.к. переменная типа uint8_t то она сама сбросится в 0 после значения 255)
         if(millis() % 5000 < 2){if(e){b++; e=false;}}else{e=true;}                         // Увеличиваем   значение переменной (b) на 1 за каждые 5 сек (по 5 секунд демонстрируется каждый вариант походки)
//       Выполняем 1 из 9 предложенных вариантов поведения (в зависимости от значения b)    // Устанавливаем значения переменным limWidth, limHeight и вызываем функцию funLimbGait() с различными параметрами
         switch(b){                                                                         //
             case  1: limWidth= 0;  limHeight=100; funLimbGait(0,     a); break;            // Поворачиваемся на месте влево
             case  2: limWidth= 0;  limHeight=100; funLimbGait(0, 255-a); break;            // Поворачиваемся на месте вправо
             case  3: limWidth= 0;  limHeight=100; funLimbGait(1,     a); break;            // Идём вперёд походкой 1
             case  4: limWidth= 0;  limHeight=100; funLimbGait(1, 255-a); break;            // Идём назад  походкой 1
             case  5: limWidth= 0;  limHeight= 60; funLimbGait(1,     a); break;            // Идём вперёд походкой 1 с высотой 60% (пригнувшись)
             case  6: limWidth= 0;  limHeight= 30; funLimbGait(1,     a); break;            // Идём вперёд походкой 1 с высотой 30% (ползём)
             case  7: limWidth=-10; limHeight=100; funLimbGait(1,     a); break;            // Идём вперёд походкой 1 незначительно поворачивая вправо
             case  8: limWidth= 10; limHeight=100; funLimbGait(1,     a); break;            // Идём вперёд походкой 1 незначительно поворачивая влево
             case  9: funLimbFree();                                      break;            // Отдыхаем
             default: b=1;                                                                  // Начинаем цикл заново
     }   }                                                                                  //
//   Проверяем наличие препятствий:                                                         //
                                                                                  //
}                                                                                   //
// ======================================================================================== //
                                                                                            //
//   Функция установки одного сустава конечности в значение от -100 до 100:                 //
void funLimbMove(uint8_t num, bool joint, int8_t pos){                                      // Аргументы функции: (num) - номер конечности от 1 до 4 , (joint) - тип сустава 0 (горизонтальный) или 1 (вертикальный) , (pos) - положение сустава от -100 (внизу-сзади) до +100 (вверху-спереди)
     uint8_t   i = (num-1) * 2 + joint;                                                     // Определяем № сервопривода (i) по № конечности (num-1) и типу сустава (joint)
     int       k = 0, j = pos? cenAngle[i]:0;                                               // Определяем переменные (j) и (k) для хранения экстремумов
     if(pos>0){k = +100; if( num%2==0||i%2==1 ){j-=maxAngle[i];}else{j+=maxAngle[i];}}      // Находим (k) - максимально допустимое значение для аргумента (pos). Находим (j) - максимально допустимый угол в градусах.
     if(pos<0){k = -100; if( num%2==1&&i%2==0 ){j-=minAngle[i];}else{j+=minAngle[i];}}      // Находим (k) - минимально  допустимое значение для аргумента (pos). Находим (j) - минимально  допустимый угол в градусах.
     if(!objServo[i].attached()){objServo[i].attach(pinServo[i]);}                          // Подключаем объект (objServo) работающий с сервоприводом (i) к выводу (pinServo[i])
         objServo[i].write(map(pos, 0, k, cenAngle[i], j));                                 // Устанавливаем сервопривод (i) в угол находящийся между центром (cenAngle[I]) и экстремумом (j)
}                                                                                           //
//   Функция установки одной конечности в положение от 0 до 255:                            //
void funLimbStep(uint8_t num, uint8_t pos){                                                 // Аргументы функции: (num) - номер конечности от 1 до 4 , (pos) - позиция от 0 до 255
     int i, j;                                                                              // Объявляем переменные (i) - для
     if(pos < 225){i = map(pos,   0, 212, +100, -100); }else                                // Сустав конечности поворачивается назад                            (+100 >>> -100)
                  {i = map(pos, 225, 255, -100, +100); }                                    // Сустав конечности поворачивается вперёд                           (-100 >>> +100)
     if(pos < 225){j =                    -100;        }else                                // Сустав конечности опущен                                          (-100)
     if(pos < 235){j = map(pos, 235, 245, -100, +100); }else                                // Сустав конечности поднимается вверх                               (-100 >>> +100)
     if(pos < 245){j =                    +100;        }else                                // Сустав конечности поднят                                          (+100)
                  {j = map(pos, 245, 255, +100, -100); }                                    // Сустав конечности опускается вниз                                 (+100 >>> -100)
     if(limWidth<0 && num%2==0){ i = map(i, -100, +100, -(100+limWidth)   , 100+limWidth);} // Ограничиваем  угол (i) горизонтального сустава левых  конечностей (поворот влево)
     if(limWidth>0 && num%2==1){ i = map(i, -100, +100, -(100-limWidth)   , 100-limWidth);} // Ограничиваем  угол (i) горизонтального сустава правых конечностей (поворот вправо)
                                 j = map(j, -100, +100, limHeight*(-2)+100, 100         );  // Ограничиваем  угол (j) вертикального   сустава любых  конечностей (высота хексапода)
     funLimbMove(num, 0, i);                                                                // Устанавливаем угол (i) для горизонтального (0) сустава конечности (num)
     funLimbMove(num, 1, j);                                                                // Устанавливаем угол (j) для вертикального   (1) сустава конечности (num)
}                                                                                           //
//   Функция выполнения походки по одному из возможных вариантов i                          //
void funLimbGait(uint8_t num, uint8_t pos){                                                 // Аргументы функции: (num) - номер походки от 0 до 2 , (pos) - позиция от 0 до 255
     switch(num){                                                                           //
//       Разворот на месте:                                                                 // pos = 0         63       127       191       255
         case 0:                                                                            //       |         |         |         |         |
             funLimbStep(1,  31-pos);                                                       //  L    | < < >>> | < < < < | < < < < | < < < < | конечность №1 выполняет полный цикл движений (от 255 до 0) быстро возвращаясь в первой тетраде
             funLimbStep(2,   0+pos);                                                       //  R    | > > > > | > > > > | > > > > | > > <<< | конечность №2 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
             funLimbStep(3,  95-pos);                                                       //  L    | < < < < | < < >>> | < < < < | < < < < | конечность №3 выполняет полный цикл движений (от 255 до 0) быстро возвращаясь во второй тетраде
             funLimbStep(4,  63+pos);                                                       //  R    | > > > > | > > > > | > > <<< | > > > > | конечность №4 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в предпоследней тетраде
         break;                                                                             //       |         |         |         |         |
//       Походка №1 вперёд или назад:                                                      // pos = 0         63       127       191       255
         case 1:                                                                            //       |         |         |         |         |
             funLimbStep(1,   0+pos);                                                       //  L    | > > > > | > > > > | > > > > | > > <<< | конечность №1 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
             funLimbStep(2, 127+pos);                                                       //  R    | > > > > | > > <<< | > > > > | > > > > | конечность №2 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь во второй тетраде
             funLimbStep(3,  63+pos);                                                       //  L    | > > > > | > > > > | > > <<< | > > > > | конечность №3 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в предпоследней тетраде
             funLimbStep(4, 191+pos);                                                       //  R    | > > <<< | > > > > | > > > > | > > > > | конечность №4 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в первой тетраде
         break;                                                                             //       |         |         |         |         |
//       Походка №2 плывёт вперёд или назад:                                               // pos = 0         63       127       191       255
         case 2:                                                                            //       |         |         |         |         |
             funLimbStep(1,   0+pos);                                                       //  L    | > > > > | > > > > | > > > > | > > <<< | конечность №1 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
             funLimbStep(2,   0+pos);                                                       //  R    | > > > > | > > > > | > > > > | > > <<< | конечность №2 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
             funLimbStep(3,   0+pos);                                                       //  L    | > > > > | > > > > | > > > > | > > <<< | конечность №3 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
             funLimbStep(4,   0+pos);                                                       //  R    | > > > > | > > > > | > > > > | > > <<< | конечность №4 выполняет полный цикл движений (от 0 до 255) быстро возвращаясь в последней тетраде
         break;                                                                             //       |         |         |         |         |
}    }                                                                                      //
//   Функция освобождения конечностей:                                                      // Аргументы функции: отсутствуют
void funLimbFree(void){for(uint8_t i=0; i<8; i++){objServo[i].detach(); digitalWrite(pinServo[i],LOW);}}
//   Функция установки всех суставов конечностей в центральное положение:                   // Аргументы функции: отсутствуют
void funLimbCent(void){for(uint8_t i=1; i<=4; i++){funLimbMove(i,0,0); funLimbMove(i,1,0);}}//
